---
title: "prem_analysis"
author: "Catharina Vendl, Patrice Pottier, Matthew Taylor, Jennifer Braeunig, Matthew Gibson, Daniel Hesselson, G. Gregory Neely, Malgorzata Lagisz, Shinichi Nakagawa "
date: "latest update: `r format(Sys.time(), '%d %B %Y')`"
output: rmdformats::material
editor_options: 
  chunk_output_type: console
---
# **Packages and custom functions**

```{r setup, include = FALSE}
# knitr setting
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE, 
  tidy = TRUE,
  cache = TRUE, 
  echo=TRUE
)

# this needs to be installed from github
#remotes::install_github("rvlenth/emmeans", dependencies = TRUE, build_opts = "", force=T)  # Note that the installation may not work if the folder is synchronizing with OneDrive
#devtools::install_github("daniel1noble/orchaRd", force = TRUE, build_vignettes = TRUE)
#devtools::install_github("daniel1noble/metaAidR")
```


The `lnRR_func` function is here used to calculate a log response ratio (lnRR) adjusted for small sample sizes. In addition, this formula accounts for correlated samples. 
For more details, see *Doncaster and Spake (2018) Correction for bias in meta-analysis of little-replicated studies. Methods in Ecology and Evolution; 9:634-644*

```{r}
# packages
library(tidyverse)
library(googlesheets4)
library(here)
library(metafor) 
library(metaAidR) # see a note above
library(orchaRd) # see a note above
library(ape)
library(clubSandwich)
library(metaAidR)
library(patchwork)
library(emmeans) # see a note above
library(kableExtra)
library(GGally)
library(cowplot)

# Below is the custom function to calculate the lnRR 
lnRR_func <- function(Mc, Nc, Me, Ne, aCV2c, aCV2e, rho = 0.5){
  lnRR <- log(Me/Mc) + 
        0.5 * ((aCV2e/Ne) - (aCV2c/Nc))	
  
  var_lnRR <- (aCV2c/Nc) + (aCV2e/Ne) - 
         2*rho*(sqrt(aCV2c)*sqrt(aCV2e)/(Nc)) 
  
  data.frame(lnRR,var_lnRR)
}

# Mc: Concentration of PFAS of the raw (control) sample
# Nc: Sample size of the raw (control) sample
# Me: Concentration of PFAS of the cooked (experimental) sample
# Ne: Sample size of the cooked (experimental) sample 
# aCV2c: Mean coefficient of variation of the raw (control) samples
# aCV2e: Mean coefficient of variation of the cooked (experimental) samples


```

# **Data import and processing**

## Import and process raw data 

### Import raw data
```{r, eval=F}
raw_data <- read_sheet("https://docs.google.com/spreadsheets/d/1cbmYDfIc2dxHJxBaowojUZZkN31NW4sL_pHw0t9eTTU/edit#gid=477880397", range = "Data_extraction_2", skip=1, col_types = "ccncccccncncccccnncccnccnncncnccnnncncncccccccc") # Import raw data
```

### Process raw data
```{r, eval=F}
processed_data <- filter(raw_data, !PFAS_type == 'PFOS_Total')
processed_data <- filter(processed_data, !Species_common == 'Fish cake')

write.csv(processed_data, here("data", "pilot_data_preprocessed.csv"), row.names = F)
```



### Load processed data
```{r}
processed_data <- read.csv(here("data", "pilot_data_preprocessed.csv")) 

dat <- processed_data %>% mutate(SDc = ifelse(Sc_technical_biological == "biological", Sc, NA), # Calculate the SD of biological replicates for control samples
                                 SDe = ifelse(Se_technical_biological == "biological", Se, NA)) # Calculate the SD of biological replicates for experimental samples



kable(dat, "html") %>% kable_styling("striped", position = "left") %>% scroll_box(width = "100%", height = "500px")
```


## Import phylogenetic information and calculate phylogenetic variance-covariance matrix 

The phylogenetic tree was generated in the `tree_cooked_fish_MA.Rmd` document 

```{r, fig.height=10, fig.width = 8}

tree <- read.tree(here("data", "plot_cooked_fish_MA.tre")) # Import phylogenetic tree (see tree_cooked_fish_MA.Rmd for more details) 

tree <- compute.brlen(tree) # Generate branch lengths 

cor_tree <- vcv(tree,corr = T) # Generate phylogenetic variance-covariance matrix 

dat$Phylogeny <- str_replace(dat$Species_Scientific, " ", "_") # Add the `phylogeny` column to the data frame

colnames(cor_tree) %in% dat$Phylogeny # Check correspondence between tip names and data frame

plot(tree)
```



## Calculate effect sizes 

The average coefficient of variation in PFAS concentration was calculated for each study and treatment, according to *Doncaster and Spake (2018) Correction for bias in meta-analysis of little-replicated studies. Methods in Ecology and Evolution; 9:634-644*. 
Then, these values were averaged across studies and used to calculate the lnRR corrected for small sample sizes (for formula, see the `lnRR_func` above)

```{r}
aCV2 <- dat %>% 
               group_by(Study_ID) %>%  # Group by study 
                                     summarise(CV2c = mean((SDc/Mc)^2, na.rm = T),  # Calculate the squared coefficient of variation for control and experimental groups
                                               CV2e = mean((SDe/Me)^2, na.rm = T)) %>% 
                                                                                      ungroup() %>% # ungroup 
                                                                                                   summarise(aCV2c = mean(CV2c, na.rm = T), # Mean CV^2 for exp and control groups across studies
                                                                                                             aCV2e = mean(CV2e, na.rm = T)) 

effect <- lnRR_func(Mc = dat$Mc, 
                    Nc = dat$Nc, 
                    Me = dat$Me, 
                    Ne = dat$Ne, 
                    aCV2c = aCV2[[1]], 
                    aCV2e = aCV2[[2]],
                    rho = 0.8)  # Calculate effect sizes

dat <- dat %>% 
             mutate(N_tilde = (Nc*Ne)/(Nc + Ne)) # Calculate the effective sample size

dat <- cbind(dat, effect) # Merge effect sizes with the data frame

VCV_lnRR <- make_VCV_matrix(dat, V = "var_lnRR", cluster = "Cohort_ID", obs = "Effect_ID", rho = 0.5) # Because some effect sizes share the same control, we generated a variance-covariance matrix to account for correlated errors (i.e. effectively dividing the weight of the correlated estimates by half)

```

## Distribution of effect sizes 

```{r, fig.height=8, fig.width=8}
# mean 
ggplot(dat, aes(x=lnRR))+ geom_histogram(fill = "salmon", col = "black", binwidth = 0.2) + theme_classic()

# variance
ggplot(dat, aes(x=var_lnRR))+ geom_histogram(fill = "salmon", col = "black", binwidth = 0.05) + theme_classic()

# log variance
ggplot(dat, aes(x=var_lnRR))+ geom_histogram(fill = "salmon", col = "black", binwidth = 0.05) + scale_x_log10()+theme_classic()
```

# **Sample sizes**

## Table of sample sizes 

```{r}
dat %>%
       summarise( # Calculate the number of effect sizes, studies and species for the main categorical variables
                 `Studies` = n_distinct(Study_ID),
                 `Species` = n_distinct(Species_common),
                 `PFAS type` = n_distinct(PFAS_type),
                 `Cohorts` = n_distinct(Cohort_ID),
                 `Effect sizes` = n_distinct(Effect_ID),
    
                 `Effect sizes (Oil-based)` = n_distinct(Effect_ID[Cooking_Category=="oil-based"]),
                 `Studies (Oil-based)` = n_distinct(Study_ID[Cooking_Category=="oil-based"]),
                 `Species (Oil-based)` = n_distinct(Species_common[Cooking_Category=="oil-based"]),

                 `Effect sizes (Water-based)` = n_distinct(Effect_ID[Cooking_Category=="water-based"]),
                 `Studies (Water-based)` = n_distinct(Study_ID[Cooking_Category=="water-based"]),
                 `Species (Water-based)` = n_distinct(Species_common[Cooking_Category=="water-based"]),

                 `Effect sizes (No liquid)` = n_distinct(Effect_ID[Cooking_Category=="No liquid"]),
                 `Studies (No liquid)` = n_distinct(Study_ID[Cooking_Category=="No liquid"]),
                 `Species (No liquid)` = n_distinct(Species_common[Cooking_Category=="No liquid"]),) -> table_sample_sizes

table_sample_sizes<-t(table_sample_sizes)
colnames(table_sample_sizes)<-"n (sample size)"
kable(table_sample_sizes) %>% kable_styling("striped", position="left")
```

## Summary of the dataset 

```{r}
kable(summary(dat), "html") %>% kable_styling("striped", position = "left") %>% 
    scroll_box(width = "100%", height = "500px")
```


# **Intercept meta-analytical model**

## Determine the random effect structure

`Cohort_ID` explains virtually no variance in the model. Hence, it was removed from the model. All the other random effects explained significant variance and were kept in subsequent models 

```{r}

MA_all_rand_effects <- rma.mv(lnRR, VCV_lnRR, # Add `VCV_lnRR` to account for correlated errors errors between cohorts (shared_controls)
              random = list(~1|Study_ID, # Identity of the study
                            ~1|Phylogeny, # Phylogenetic correlation
                            ~1|Cohort_ID, # Identity of the cohort (shared controls)
                            ~1|Species_common, # Non-phylogenetic correlation between species
                            ~1|PFAS_type, # Type of PFAS 
                            ~1|Effect_ID), # Effect size identity 
              R= list(Phylogeny = cor_tree), # Assign the 'Phylogeny' argument to the phylogenetic variance-covariance matrix
              test = "t", 
              data = dat)

summary(MA_all_rand_effects) # Cohort ID does not explain any variance 

```


## Intercept meta-analytical model and percentage of heterogeneity 

```{r, fig.height=6, fig.width=9}
MA_model <- rma.mv(lnRR, VCV_lnRR, 
              random = list(~1|Study_ID,
                            ~1|Phylogeny, # Removed Cohort_ID
                            ~1|Species_common, 
                            ~1|PFAS_type, 
                            ~1|Effect_ID), 
              R= list(Phylogeny = cor_tree), 
              test = "t", 
              data = dat)

summary(MA_model)
i2_ml(MA_model) # Percentage of heterogeneity explained by each random effect

# plot
orchard_plot(MA_model, mod = "Int", xlab = "lnRR", alpha=0.4) +  # Orchard plot 
           geom_errorbarh(aes(xmin = lowerPR, xmax = upperPR), height = 0, show.legend = FALSE, size = 1.1, alpha = 0.5)+ # prediction intervals
           geom_errorbarh(aes(xmin = lowerCL, xmax = upperCL), height = 0.05, show.legend = FALSE, size = 2)+ # confidence intervals
           geom_point(aes(fill = name),  size = 5, shape = 21)+ # mean estimate
           scale_colour_manual(values = "darkorange")+ # change colours
           scale_fill_manual(values="darkorange")+ 
           scale_size_continuous(range = c(1, 7))+ # change point scaling
           theme(panel.border = element_rect(colour = "black", fill=NA, size=1.3), # border around the plot
                 text = element_text(size = 24), # change font sizes
                 legend.title = element_text(size = 15),
                 legend.text = element_text(size = 13)) 

save(MA_model, MA_all_rand_effects, file = here("Rdata", "int_MA_models.RData")) # save the models 
```


```{r, include = FALSE}
# Because the models are saved, this code chunk can be used to see the models output without running the models
load(here("Rdata", "int_MA_models.RData"))

summary(MA_all_rand_effects)
summary(MA_model)

i2_ml(MA_model)

```


# **Meta-regressions**

## Function to run all models with the same structure

```{r}
run_model<-function(data,formula){
  data<-as.data.frame(data) # convert data set into a data frame to calculate VCV matrix 
  VCV<-make_VCV_matrix(data
                       , V = "var_lnRR", cluster = "Cohort_ID", obs = "Effect_ID", rho = 0.5) # create VCV matrix for the specified data
  
  rma.mv(lnRR, VCV, # run the model, as described earlier
         mods=formula,
         random = list(~1|Study_ID,
                       ~1|Phylogeny, 
                       ~1|Species_common, 
                       ~1|PFAS_type, 
                       ~1|Effect_ID), 
         R= list(Phylogeny = cor_tree), 
         test = "t", 
         data = data)
}

```


## Function to run plots with the same structure

```{r}
plot_continuous<-function(data, model, moderator, xlab){

pred<-predict.rma(model)

data %>% mutate(fit=pred$pred, 
               ci.lb=pred$ci.lb,
               ci.ub=pred$ci.ub,
               pr.lb=pred$cr.lb,
               pr.ub=pred$cr.ub) %>% 
ggplot(aes(x = moderator, y = lnRR)) +
     geom_ribbon(aes(ymin = pr.lb, ymax = pr.ub, color = NULL), alpha = .075) +
     geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = .2) +
     geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
     scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
     geom_line(aes(y = fit), size = 1.5)+  
  labs(x = xlab, y = "lnRR", size = "Precison (1/SE)") +
  theme_bw() +
  scale_size_continuous(range=c(1,9))+
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
}

```


## Single-moderator models {.tabset .tabset_fade .tabset_pills} 

All continuous variables were z-transformed

### Cooking time 

```{r, fig.width=10, fig.height=7}
# Length_cooking_time_in_s

time_model<-run_model(dat, ~scale(Length_cooking_time_in_s)) # z-transformed
  
summary(time_model)
r2_ml(time_model)

# Plot
dat.time<-filter(dat, Length_cooking_time_in_s!="NA")
plot_continuous(dat.time, time_model, dat.time$Length_cooking_time_in_s, "Cooking time (s)")
```

### Volume of liquid 

```{r, fig.width=10, fig.height=7}
# Volume_liquid_ml

volume_model<-run_model(dat, ~scale(log(Volume_liquid_ml))) # logged and z-transformed
  
summary(volume_model)
r2_ml(volume_model)

# Plot
dat.volume<-filter(dat, Volume_liquid_ml!="NA")
plot_continuous(dat.volume, volume_model, log(dat.volume$Volume_liquid_ml), "Volume of liquid (mL)")
```


### Cooking temperature 

```{r, fig.width=10, fig.height=7}
# Temperature_in_Celsius

temp_model<-run_model(dat, ~scale(Temperature_in_Celsius)) # z-transformed 
  
summary(temp_model)
r2_ml(temp_model)

# Plot
dat.temp<-filter(dat, Temperature_in_Celsius!="NA")
plot_continuous(dat.temp, temp_model, dat.temp$Temperature_in_Celsius, "Cooking temperature")
```

### PFAS carbon chain length 

```{r, fig.width=10, fig.height=7}
# PFAS_carbon_chain

PFAS_model<-run_model(dat, ~PFAS_carbon_chain)
  
summary(PFAS_model)
r2_ml(PFAS_model)

plot_continuous(dat, PFAS_model, dat$PFAS_carbon_chain, "PFAS carbon chain length")

```


### Cooking category 

```{r, fig.width=9, fig.height=6}
# Cooking_Category

category_model<-run_model(dat, ~Cooking_Category-1)
  
summary(category_model)
r2_ml(category_model)

# plot
orchard_plot(category_model, mod = "Cooking_Category", xlab = "lnRR", alpha=0.4)+
           geom_errorbarh(aes(xmin = lowerPR, xmax = upperPR), height = 0, show.legend = FALSE, size = 1.1, alpha = 0.5)+ # prediction intervals
           geom_errorbarh(aes(xmin = lowerCL, xmax = upperCL), height = 0, show.legend = FALSE, size = 2)+ # confidence intervals
           geom_point(aes(fill = name),  size = 5, shape = 21)+ # mean estimate
           scale_colour_manual(values = c("#55C667FF", "goldenrod2", "dodgerblue3"))+ # change colours
           scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+ 
           scale_size_continuous(range = c(1, 7))+ # change point scaling
           theme(panel.border = element_rect(colour = "black", fill=NA, size=1.3), # border around the plot
                 text = element_text(size = 24), # change font sizes
                 legend.title = element_text(size = 15),
                 legend.text = element_text(size = 13))
```


### Percentage of moisture loss

This analysis is *a posteriori* and will only be presented in supplement. 
```{r, fig.width=10, fig.height=7}
# Moisture_loss_in_percent

moisture_model<-run_model(dat, ~scale(Moisture_loss_in_percent))
  
summary(moisture_model)
r2_ml(moisture_model)

# Plot
dat.moisture<-filter(dat, Moisture_loss_in_percent!="NA")
plot_continuous(dat.moisture, moisture_model, dat.moisture$Moisture_loss_in_percent, "Percentage of moisture loss")
```


```{r}
save(category_model, PFAS_model, temp_model, time_model, volume_model, moisture_model, file = here("Rdata", "single_mod_models.RData")) # Save models
```


```{r, include= FALSE}
load(here("Rdata", "single_mod_models.RData")) # Load the output of the models to avoid running them 

# Cooking time
summary(time_model)
r2_ml(time_model)

# Volume of liquid
summary(volume_model)
r2_ml(volume_model)

# Cooking temperature
summary(temp_model)
r2_ml(temp_model)

# PFAS carbon chain length
summary(PFAS_model)
r2_ml(PFAS_model)

# Cooking category
summary(category_model)
r2_ml(category_model)

# Percentage of moisture loss
summary(moisture_model)
r2_ml(moisture_model)
```


###


## Full model 

```{r}

# Full_model 

full_model <- run_model(dat, ~ - 1 + 
                               Cooking_Category +
                               scale(Temperature_in_Celsius) +
                               scale(Length_cooking_time_in_s) +
                               scale(PFAS_carbon_chain) +
                               scale(log(Volume_liquid_ml)))
summary(full_model)
r2_ml(full_model)


full_modelb <- run_model(dat, ~ 1 +
                               relevel(factor(Cooking_Category),ref =  "oil-based") +
                               scale(Temperature_in_Celsius) +
                               scale(Length_cooking_time_in_s) +
                               scale(PFAS_carbon_chain) +
                               scale(log(Volume_liquid_ml)))
summary(full_modelb)


full_modelc <- run_model(dat, ~ 1 +
                               relevel(factor(Cooking_Category),ref =  "No liquid") +
                               scale(Temperature_in_Celsius) +
                               scale(Length_cooking_time_in_s) +
                               scale(PFAS_carbon_chain) +
                               scale(log(Volume_liquid_ml)))
summary(full_modelc)


# testing cooking categories  
full_modeld  <- rma.mv(yi = lnRR, V = VCV_lnRR, # run the model, as described earlier
                         mods= ~-1 +
                               Cooking_Category +
                               scale(Temperature_in_Celsius) +
                               scale(Length_cooking_time_in_s) +
                               scale(PFAS_carbon_chain) +
                               scale(log(Volume_liquid_ml)),
         random = list(~1|Study_ID,
                       ~1|Phylogeny, 
                       ~1|Species_common, 
                       ~1|PFAS_type, 
                       ~1|Effect_ID), 
         R= list(Phylogeny = cor_tree), 
         test = "t", 
         data = dat,
         btt = c(1:3)) # testing the significance of cooking category - testing first 3 regression coefficients) 

summary(full_modeld)


save(full_model,full_modelb,full_modelc,full_modeld, file = here("Rdata", "full_model.RData"))

```

### Check collinearity of predictors 

```{r, fig.width=9}
## Check for collinerarity - seems fine

vif(full_model)

dat %>% select(Temperature_in_Celsius, Length_cooking_time_in_s, PFAS_carbon_chain, Volume_liquid_ml) %>% 
  ggpairs()
```


```{r, include = FALSE}

load(here("Rdata", "full_model.RData")) # Load the output of the full model to avoid running it

summary(full_model)

summary(full_modelb)

summary(full_modelc)

summary(full_modeld)

```



# **Conditional analyses** {.tabset .tabset_fade .tabset_pills} 


Inspection of the plots highlighted potential significant decreases in PFAS content with increased cooking time and volume of cooking. 
Hence, here we used `emmeans` (download from *remotes::install_github("rvlenth/emmeans", dependencies = TRUE, build_opts = "")*) to generate marginalised means at specified values of the different predictors. 
Such analysis enable the quantification of the mean effect size after controlling for different values of the moderators. 

## Full model 

```{r}
# Full model in original units (no z-transformation)
dat$log_Volume_liquid_ml<-log(dat$Volume_liquid_ml)

full_model_org_units <- run_model(dat, ~ - 1 + 
                               Cooking_Category +
                               Temperature_in_Celsius +
                               Length_cooking_time_in_s +
                               PFAS_carbon_chain +
                               log_Volume_liquid_ml)


# Full model in original units (no z-transformation), but without the "No liquid" data
# This model will be used for conditional analyses on the volume of liquid, where the data without liquid is irrelevant. 
dat_oil_water<-filter(dat, Cooking_Category!="No liquid")

full_model_org_units_oil_water<- run_model(dat_oil_water, ~ - 1 + 
                               Cooking_Category +
                               Temperature_in_Celsius +
                               Length_cooking_time_in_s +
                               PFAS_carbon_chain +
                               log_Volume_liquid_ml)


save(full_model_org_units,full_model_org_units_oil_water, file = here("Rdata", "full_models_org_units.RData"))
```

```{r, include=FALSE}
load(here("Rdata", "full_models_org_units.RData")) # Load the output of the model to avoid running it

summary(full_model_org_units)
summary(full_model_org_units_oil_water)
```


## Overall marginalised mean 

```{r}
res<-marginal_means(full_model_org_units, data=dat, mod="1")
res$mod_table
```

## Marginal means for different cooking categories

```{r, fig.width=10, fig.height=7}
res_cat<-marginal_means(full_model_org_units, data = dat, mod = "1", by = "Cooking_Category")
res_cat$mod_table

orchard_plot(res_cat, xlab = "lnRR", condition.lab = "Cooking Category" )
```

## Marginal means for pre-determined cooking times

Here, we generate estimates at cooking times of 2, 10, and 25 min. 

```{r, fig.width=10, fig.height=7}
res_cooking_time <-marginal_means(full_model_org_units, data = dat, mod = "1", at = list(Length_cooking_time_in_s = c(120,600,1500)), by = "Length_cooking_time_in_s")
res_cooking_time$mod_table

orchard_plot(res_cooking_time, xlab = "lnRR", condition.lab = "Cooking time (sec)")

```

Marginalised means for each cooking category, at different cooking times

```{r, fig.width=10, fig.height=7}
res_cooking_time_cat <-marginal_means(full_model_org_units, data = dat, mod = "Cooking_Category", at = list(Length_cooking_time_in_s = c(120,600,1500)), by = "Length_cooking_time_in_s")
res_cooking_time_cat$mod_table

orchard_plot(res_cooking_time_cat, xlab = "lnRR", condition.lab = "Cooking time (sec)")

```



## Marginal means for different volumes of liquid

Here, we generate marginalised estimates at volumes of liquid of ~10, 500, and 10000 mL. We did not look at the means for different cooking categories because they are inherently different in the volume of liquid used. 
We also only used the data on oil and water because the "No liquid" category is not relevant for this analysis. 

```{r, fig.width=10, fig.height=7}
res_volume<-marginal_means(full_model_org_units_oil_water, data = dat_oil_water, mod = "1", at = list(log_Volume_liquid_ml = c(2.3, 5.5, 9.2)), by = "log_Volume_liquid_ml")
res_volume$mod_table

orchard_plot(res_volume, xlab = "lnRR", condition.lab = "ln(liquid volume (ml))")
```

## Marginal means for different PFAS carbon chains

Here, we generate marginalized estimates for PFAS of 3, 6, and 12 carbon chains

```{r, fig.width=10, fig.height=7}
res_PFAS<-marginal_means(full_model_org_units, data = dat, mod = "1", at = list(PFAS_carbon_chain= c(3, 6, 12)), by = "PFAS_carbon_chain")
res_PFAS$mod_table

orchard_plot(res_PFAS, xlab = "lnRR", condition.lab = "PFAS carbon chain")
```

 Marginalised mean estimate for each PFAS carbon chain, for each cooking category 

```{r, fig.width=10, fig.height=7}
res_PFAS_cat<-marginal_means(full_model_org_units, data = dat, mod = "Cooking_Category", at = list(PFAS_carbon_chain= c(3, 6, 12)), by = "PFAS_carbon_chain")
res_PFAS_cat$mod_table

orchard_plot(res_PFAS_cat, xlab = "lnRR", condition.lab = "PFAS carbon chain")
```
##


# **Sub-group analyses for each cooking category** {.tabset .tabset_fade .tabset_pills} 

Here, we investigated whether the effect of the continuous moderators on lnRR vary depending on the cooking category. Hence, we performed subset analyses for each cooking category. 

## Oil-based cooking

### Subset data and update function
```{r}
oil_dat<-filter(dat, Cooking_Category=="oil-based")

include <- row.names(cor_tree) %in% oil_dat$Phylogeny # Check which rows are present in the phylogenetic tree 
cor_tree_oil <- cor_tree[include, include] # Only include the species that match the reduced data set 


run_model_oil<-function(data,formula){
  data<-as.data.frame(data) # convert data set into a data frame to calculate VCV matrix 
  VCV<-make_VCV_matrix(data, V = "var_lnRR", cluster = "Cohort_ID", obs = "Effect_ID", rho = 0.5) # create VCV matrix for the specified data
  
  rma.mv(lnRR, VCV, # run the model, as described earlier
         mods=formula,
         random = list(~1|Study_ID,
                       ~1|Phylogeny, 
                       ~1|Species_common, 
                       ~1|PFAS_type, 
                       ~1|Effect_ID), 
         R= list(Phylogeny = cor_tree_oil), # cor_tree_oil here
         test = "t", 
         data = data)
}
```

### Full model 

```{r}
full_model_oil <- run_model_oil(oil_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s) +
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))
                 
summary(full_model_oil)

save(full_model_oil, file = here("Rdata", "full_model_oil.RData"))
            
```

```{r, include=F}
load(here("Rdata", "full_model_oil.RData"))
summary(full_model_oil)
```


## Water-based cooking

### Subset data and updating functions
```{r}
water_dat<-filter(dat, Cooking_Category=="water-based")

include <- row.names(cor_tree) %in% water_dat$Phylogeny # Check which rows are present in the phylogenetic tree 
cor_tree_water <- cor_tree[include, include] # Only include the species that match the reduced data set 


run_model_water<-function(data,formula){
  data<-as.data.frame(data) # convert data set into a data frame to calculate VCV matrix 
  VCV<-make_VCV_matrix(data, V = "var_lnRR", cluster = "Cohort_ID", obs = "Effect_ID", rho = 0.5) # create VCV matrix for the specified data
  
  rma.mv(lnRR, VCV, # run the model, as described earlier
         mods=formula,
         random = list(~1|Study_ID,
                       ~1|Phylogeny, 
                       ~1|Species_common, 
                       ~1|PFAS_type, 
                       ~1|Effect_ID), 
         R= list(Phylogeny = cor_tree_water), # cor_tree_water here
         test = "t", 
         data = data)
}
```


### Full model 

```{r}
full_model_water <- run_model_water(water_dat, ~
                                           scale(Length_cooking_time_in_s) +
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))
                 
summary(full_model_water)
```


### Comparison between steaming and other water-based cooking categories

In our data set, the studies using steaming-based cooking were considered to have an unknown (i.e. NA) because of the difficulty to assess how much liquid gets in contact with the products. 
Here, we provide an analysis to compare steaming with other water-based cooking categories
```{r}
water_dat$steamed<-ifelse(water_dat$Cooking_method=="Steaming","steamed","other") # create a dummy variable to differentiate "steaming" with other types of water-based cooking

full_model_water_steamed <- run_model_water(water_dat, ~ -1 + # without intercept
                                                steamed +
                                                scale(Length_cooking_time_in_s) +
                                                scale(PFAS_carbon_chain)) # In this case, we need to remove the volume of liquid from the model. Otherwise, it would remove observations with steaming cooking. 

summary(full_model_water_steamed)

# Contrast between steamed and non-steamed
full_model_water_steamed_cont <- run_model_water(water_dat,  
                                             ~  steamed + # with intercept
                                                scale(Length_cooking_time_in_s) +
                                                scale(PFAS_carbon_chain)) 

summary(full_model_water_steamed_cont)

save(full_model_water, full_model_water_steamed, full_model_water_steamed_cont, file = here("Rdata", "full_model_water.RData"))
```


```{r, include=F}
load(here("Rdata", "full_model_water.RData"))
summary(full_model_water)
summary(full_model_water_steamed)
```


## Dry cooking 

Not very relevant because all effect sizes are from one study here. Also, the model does not converge when adding `VCV_lnRR`
```{r}
dry_dat<-filter(dat, Cooking_Category=="No liquid")

include <- row.names(cor_tree) %in% dry_dat$Phylogeny # Check which rows are present in the phylogenetic tree 
cor_tree_dry <- cor_tree[include, include] # Only include the species that match the reduced data set 


run_model_dry<-function(data,formula){
  data<-as.data.frame(data) # convert data set into a data frame to calculate VCV matrix 
  rma.mv(lnRR, var_lnRR, # run the model with var_lnRR instead of VCV
         mods=formula,
         random = list(~1|Study_ID,
                       ~1|Phylogeny, 
                       ~1|Species_common, 
                       ~1|PFAS_type, 
                       ~1|Effect_ID), 
         R= list(Phylogeny = cor_tree_dry), # cor_tree_dry here
         test = "t", 
         data = data)
}
```


### Full model 


```{r}
full_model_dry <- run_model_dry(dry_dat, ~ scale(Length_cooking_time_in_s)) # Model does not converge with VCV_lnRR
                 
summary(full_model_dry)

save(full_model_dry, file = here("Rdata", "full_model_dry.RData"))
```


```{r, include=F}
load(here("Rdata", "full_model_dry.RData"))
summary(full_model_dry)
```

##


# **Plots** {.tabset .tabset_fade .tabset_pills} 

## Cooking time

### Generate predictions
```{r}

  oil_dat <- filter(dat, Cooking_Category=="oil-based")
  water_dat <- filter(dat, Cooking_Category=="water-based")
  dry_dat <- filter(dat, Cooking_Category=="No liquid")

  oil_dat_time<-filter(oil_dat, Length_cooking_time_in_s!="NA") 
  water_dat_time<-filter(water_dat, Length_cooking_time_in_s!="NA") 
  dry_dat_time<-filter(dry_dat, Length_cooking_time_in_s!="NA")
  
model_oil_time<-run_model_oil(oil_dat_time, ~Length_cooking_time_in_s) 
model_water_time<-run_model_water(water_dat_time, ~Length_cooking_time_in_s) 
model_dry_time<-run_model_dry(dry_dat_time, ~Length_cooking_time_in_s) 


pred_oil_time<-predict.rma(model_oil_time)
pred_water_time<-predict.rma(model_water_time)
pred_dry_time<-predict.rma(model_dry_time)

oil_dat_time<-mutate(oil_dat_time,
                    ci.lb = pred_oil_time$ci.lb, # lower bound of the confidence interval for oil
                    ci.ub = pred_oil_time$ci.ub, # upper bound of the confidence interval for oil
                    fit = pred_oil_time$pred) # regression line for oil

water_dat_time<-mutate(water_dat_time,
                    ci.lb = pred_water_time$ci.lb, # lower bound of the confidence interval for water
                    ci.ub = pred_water_time$ci.ub, # upper bound of the confidence interval for water
                    fit = pred_water_time$pred) # regression line for water

dry_dat_time<-mutate(dry_dat_time,
                    ci.lb = pred_dry_time$ci.lb, # lower bound of the confidence interval for dry
                    ci.ub = pred_dry_time$ci.ub, # upper bound of the confidence interval for dry
                    fit = pred_dry_time$pred) # regression line for dry

```


### Plot
```{r, fig.height=8, fig.width=10}

ggplot(dat,aes(x = Length_cooking_time_in_s, y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=water_dat_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=water_dat_time,aes(y = fit), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=oil_dat_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=oil_dat_time,aes(y = fit), size = 1.5, col="goldenrod")+  
  
         geom_ribbon(data=dry_dat_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=dry_dat_time,aes(y = fit), size = 1.5, col="palegreen3")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "Cooking time (s)", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))

```

### Predictions with the full model

```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_time<- run_model_oil(oil_dat, ~ scale(Temperature_in_Celsius) +
                                           Length_cooking_time_in_s+
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))

pred_oil_time<-predict.rma(full_model_oil_time, addx=TRUE, newmods=cbind(0,c(120:1500), 0, 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_oil_time<-as.data.frame(pred_oil_time)
pred_oil_time$Length_cooking_time_in_s=pred_oil_time$X.Length_cooking_time_in_s
pred_oil_time<-left_join(oil_dat, pred_oil_time, by="Length_cooking_time_in_s")


##### Water based
full_model_water_time<- run_model_water(water_dat, ~ scale(Temperature_in_Celsius) +
                                           Length_cooking_time_in_s+
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))

pred_water_time<-predict.rma(full_model_water_time, addx=TRUE, newmods=cbind(c(120:1500), 0, 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_water_time<-as.data.frame(pred_water_time)
pred_water_time$Length_cooking_time_in_s=pred_water_time$X.Length_cooking_time_in_s
pred_water_time<-left_join(water_dat, pred_water_time, by="Length_cooking_time_in_s")

##### No liquid 

full_model_dry_time<- run_model_dry(dry_dat, ~ Length_cooking_time_in_s)

pred_dry_time<-predict.rma(full_model_dry_time, addx=TRUE) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_dry_time<-as.data.frame(pred_dry_time)
pred_dry_time$Length_cooking_time_in_s=pred_dry_time$X.Length_cooking_time_in_s
pred_dry_time<-left_join(dry_dat, pred_dry_time, by="Length_cooking_time_in_s")




ggplot(dat,aes(x = Length_cooking_time_in_s, y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=pred_water_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_time,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=pred_oil_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_oil_time,aes(y = pred), size = 1.5, col="goldenrod")+  
  
        geom_ribbon(data=pred_dry_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_dry_time,aes(y = pred), size = 1.5, col="palegreen3")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "Cooking time (s)", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```




## Volume of liquid 

### Generate predictions
```{r}

  oil_dat_vol<-filter(oil_dat, Volume_liquid_ml!="NA") 
  water_dat_vol<-filter(water_dat, Volume_liquid_ml!="NA") 

model_oil_vol<-run_model_oil(oil_dat_vol, ~log(Volume_liquid_ml)) 
model_water_vol<-run_model_water(water_dat_vol, ~log(Volume_liquid_ml)) 


pred_oil_vol<-predict.rma(model_oil_vol)
pred_water_vol<-predict.rma(model_water_vol)

oil_dat_vol<-mutate(oil_dat_vol,
                    ci.lb = pred_oil_vol$ci.lb, 
                    ci.ub = pred_oil_vol$ci.ub, 
                    fit = pred_oil_vol$pred) 

water_dat_vol<-mutate(water_dat_vol,
                    ci.lb = pred_water_vol$ci.lb, 
                    ci.ub = pred_water_vol$ci.ub, 
                    fit = pred_water_vol$pred) 

oil_dat$log_Volume_liquid_ml<-log(oil_dat$Volume_liquid_ml)
water_dat$log_Volume_liquid_ml<-log(water_dat$Volume_liquid_ml)
```


### Plot
```{r, fig.height=8, fig.width=10}

ggplot(dat,aes(x = log(Volume_liquid_ml), y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=water_dat_vol, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=water_dat_vol,aes(y = fit), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=oil_dat_vol, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=oil_dat_vol,aes(y = fit), size = 1.5, col="goldenrod")+  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF","goldenrod2", "dodgerblue3"))+
       labs(x = "ln(Volume of liquid (mL))", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), 
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))

```

### Predictions with the full model

```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_vol<- run_model_oil(oil_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           scale(PFAS_carbon_chain) +
                                           log_Volume_liquid_ml)
pred_oil_vol<-predict.rma(full_model_oil_vol, addx=TRUE, newmods=cbind(0,0,0, c(log(5):log(750))))# Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time

pred_oil_vol<-as.data.frame(pred_oil_vol)
pred_oil_vol<-pred_oil_vol %>% mutate(Volume_liquid_ml=exp(X.log_Volume_liquid_ml), Cooking_Category="oil-based", lnRR=0) # for the plot to work, we need to add a column with cooking category and a column with lnRR


##### Water based 

full_model_water_vol<- run_model_water(water_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           scale(PFAS_carbon_chain) +
                                           log_Volume_liquid_ml)

pred_water_vol<-predict.rma(full_model_water_vol, addx=TRUE, newmods=cbind(0,0, c(log(250):log(59777))))# Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time

pred_water_vol<-as.data.frame(pred_water_vol)
pred_water_vol<-pred_water_vol %>% mutate(Volume_liquid_ml=exp(X.log_Volume_liquid_ml), Cooking_Category="water-based", lnRR=0)



ggplot(dat,aes(x = log(Volume_liquid_ml), y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=pred_water_vol, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_vol,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=pred_oil_vol, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=pred_oil_vol,aes(y = pred), size = 1.5, col="goldenrod")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF","goldenrod2", "dodgerblue3"))+
       labs(x = "ln(Volume of liquid (mL))", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), 
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2)) #### The line doesn't go all the way down for water-based because the highest values are not included in the full model

```




## PFAS carbon chain length

### Generate predictions
```{r}

  oil_dat_PFAS<-filter(oil_dat, PFAS_carbon_chain!="NA") 
  water_dat_PFAS<-filter(water_dat, PFAS_carbon_chain!="NA") 
  dry_dat_PFAS<-filter(dry_dat, PFAS_carbon_chain!="NA")
  
model_oil_PFAS<-run_model_oil(oil_dat_PFAS, ~PFAS_carbon_chain) 
model_water_PFAS<-run_model_water(water_dat_PFAS, ~PFAS_carbon_chain) 
model_dry_PFAS<-run_model_dry(dry_dat_PFAS, ~PFAS_carbon_chain) 


pred_oil_PFAS<-predict.rma(model_oil_PFAS)
pred_water_PFAS<-predict.rma(model_water_PFAS)
pred_dry_PFAS<-predict.rma(model_dry_PFAS)

oil_dat_PFAS<-mutate(oil_dat_PFAS,
                    ci.lb = pred_oil_PFAS$ci.lb, 
                    ci.ub = pred_oil_PFAS$ci.ub, 
                    fit = pred_oil_PFAS$pred) 

water_dat_PFAS<-mutate(water_dat_PFAS,
                    ci.lb = pred_water_PFAS$ci.lb, 
                    ci.ub = pred_water_PFAS$ci.ub, 
                    fit = pred_water_PFAS$pred) 

dry_dat_PFAS<-mutate(dry_dat_PFAS,
                    ci.lb = pred_dry_PFAS$ci.lb, 
                    ci.ub = pred_dry_PFAS$ci.ub, 
                    fit = pred_dry_PFAS$pred) 
```


### Plot
```{r, fig.height=8, fig.width=10}

ggplot(dat,aes(x = PFAS_carbon_chain, y = lnRR, fill=Cooking_Category)) +
  
      geom_ribbon(data=dry_dat_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=dry_dat_PFAS,aes(y = fit), size = 1.5, col="palegreen3")+  
  
       geom_ribbon(data=water_dat_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=water_dat_PFAS,aes(y = fit), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=oil_dat_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=oil_dat_PFAS,aes(y = fit), size = 1.5, col="goldenrod")+  
  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "PFAS carbon chain length", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), 
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))

```


### Predictions with the full model

```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_PFAS<- run_model_oil(oil_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           PFAS_carbon_chain +
                                           scale(log(Volume_liquid_ml)))
pred_oil_PFAS<-predict.rma(full_model_oil_PFAS, addx=TRUE, newmods=cbind(0,0, c(3:14),0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of PFAS carbon chain
pred_oil_PFAS<-as.data.frame(pred_oil_PFAS)
pred_oil_PFAS$PFAS_carbon_chain=pred_oil_PFAS$X.PFAS_carbon_chain
pred_oil_PFAS<-left_join(oil_dat, pred_oil_PFAS, by="PFAS_carbon_chain")


##### Water based
full_model_water_PFAS<- run_model_water(water_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           PFAS_carbon_chain +
                                           scale(log(Volume_liquid_ml)))

pred_water_PFAS<-predict.rma(full_model_water_PFAS, addx=TRUE, newmods=cbind(0, c(3:14),0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_water_PFAS<-as.data.frame(pred_water_PFAS)
pred_water_PFAS$PFAS_carbon_chain=pred_water_PFAS$X.PFAS_carbon_chain
pred_water_PFAS<-left_join(water_dat, pred_water_PFAS, by="PFAS_carbon_chain")

##### No liquid 

full_model_dry_PFAS<- run_model_dry(dry_dat, ~ PFAS_carbon_chain)

pred_dry_PFAS<-predict.rma(full_model_dry_PFAS, addx=TRUE)
pred_dry_PFAS<-as.data.frame(pred_dry_PFAS)
pred_dry_PFAS$PFAS_carbon_chain=pred_dry_PFAS$X.PFAS_carbon_chain
pred_dry_PFAS<-left_join(dry_dat, pred_dry_PFAS, by="PFAS_carbon_chain")




ggplot(dat,aes(x = PFAS_carbon_chain, y = lnRR, fill=Cooking_Category)) +
  
    
       geom_ribbon(data=pred_dry_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_dry_PFAS,aes(y = pred), size = 1.5, col="palegreen3")+  
  
  
       geom_ribbon(data=pred_water_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_PFAS,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
  
       geom_ribbon(data=pred_oil_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=pred_oil_PFAS,aes(y = pred), size = 1.5, col="goldenrod")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "PFAS carbon chain length", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```

##

# **Publication bias** {.tabset .tabset_fade .tabset_pills} 

## Funnel plot 

```{r}
funnel(full_model, yaxis = "seinv")
funnel(full_model)
```

## Egger regressions 

```{r}
egger_all <- run_model(dat, ~ - 1 + Cooking_Category +
                      I(sqrt(1/N_tilde)) +  
                      scale(Publication_year) + 
                      scale(Temperature_in_Celsius) +
                      scale(Length_cooking_time_in_s) +
                      scale(PFAS_carbon_chain) +
                      scale(log(Volume_liquid_ml)))
summary(egger_all)


funnel(egger_all, yaxis = "seinv")
funnel(egger_all)

#funnel(egger_all, yaxis = "seinv")
# little evidence
egger_n <- run_model(dat, ~ I(sqrt(1/N_tilde)))
summary(egger_n)

save(egger_all, egger_n, file = here("Rdata", "egger_regressions.RData"))
```
## Publication year

```{r, fig.height=8, fig.width=10}
pub_year<-run_model(dat, ~Publication_year)
summary(pub_year)

plot_continuous(dat, pub_year, dat$Publication_year, "Publication year")
```
##


# **Sensitivity analyses**
 
## Leave-one-out analyses 
 
Here, we iteratively removed one study at the time and investigated how it affects the overall mean. Removing one of the study particularly modifies the estimate, but none of these models show a significant overall difference in PFAS concentration with cooking.

 
```{r}
dat$Study_ID<-as.factor(dat$Study_ID)
dat<-as.data.frame(dat) # Only work with a dataframe
VCV_matrix<-list() # will need new VCV matrices because the sample size will be iteratively reduced
Leave1studyout<-list() # create a list that will host the results of each model 
for(i in 1:length(levels(dat$Study_ID))){ # N models = N studies 
  VCV_matrix[[i]]<-make_VCV_matrix(dat[dat$Study_ID != levels(dat$Study_ID)[i], ], V="var_lnRR", cluster="Cohort_ID", obs="Effect_ID") # Create a new VCV matrix for each new model
  Leave1studyout[[i]] <- rma.mv(yi = lnRR, V = VCV_matrix[[i]], # Same model structure as all the models we fitted
                                random = list(~1|Study_ID,
                                              ~1|Phylogeny, 
                                              ~1|Species_common, 
                                              ~1|PFAS_type, 
                                              ~1|Effect_ID),
                                R= list(Phylogeny = cor_tree), 
                                test = "t", 
                                data = dat[dat$Study_ID != levels(dat$Study_ID)[i], ]) # Generate a new model for each new data (iterative removal of one study at a time)
}

# The output is a list so we need to summarise the coefficients of all the models performed

results.Leave1studyout<-as.data.frame(cbind(
                                           sapply(Leave1studyout, function(x) summary(x)$beta), # extract the beta coefficient from all models
                                           sapply(Leave1studyout, function(x) summary(x)$se), # extract the standard error from all models
                                           sapply(Leave1studyout, function(x) summary(x)$zval),  # extract the z value from all models
                                           sapply(Leave1studyout, function(x) summary(x)$pval), # extract the p value from all models
                                           sapply(Leave1studyout, function(x) summary(x)$ci.lb), # extract the lower confidence interval for all models
                                           sapply(Leave1studyout, function(x) summary(x)$ci.ub))) # extract the upper confidence interval for all models

colnames(results.Leave1studyout)=c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names 
kable(results.Leave1studyout)%>% kable_styling("striped", position="left") %>% scroll_box(width="100%", height="500px") # Table of the results from all models


dat %>% group_by(Author_year, Study_ID) %>% summarise(mean=mean(lnRR)) # Study F005 (DelGobbo_2008) has much lower effect sizes than the others. 
```

### Subset analysis without `Study_ID F005 (Del Gobbo et al. 2008)` {.tabset .tabset_fade .tabset_pills} 

#### Cooking time 
```{r, fig.height=8, fig.width=10}

dat.sens<-filter(dat, Author_year!="DelGobbo_2008")

include <- row.names(cor_tree) %in% dat.sens$Phylogeny # Check which rows are present in the phylogenetic tree 
cor_tree_sens <- cor_tree[include, include] # Only include the species that match the reduced data set 

  dat.sens<-as.data.frame(dat.sens) # convert data set into a data frame to calculate VCV matrix 
  VCV_lnRR.sens<-make_VCV_matrix(dat.sens, V = "var_lnRR", cluster = "Cohort_ID", obs = "Effect_ID", rho = 0.5) # create VCV matrix for the specified data
  
mod.sens<- rma.mv(lnRR, VCV_lnRR.sens, 
         mods=~Length_cooking_time_in_s,
         random = list(~1|Study_ID,
                       ~1|Phylogeny, 
                       ~1|Species_common, 
                       ~1|PFAS_type, 
                       ~1|Effect_ID), 
         R= list(Phylogeny = cor_tree_sens), 
         test = "t", 
         data = dat.sens)
summary(mod.sens)

dat.time.sens<-filter(dat.sens, Length_cooking_time_in_s!="NA")
plot_continuous(dat.time.sens, mod.sens, dat.time.sens$Length_cooking_time_in_s, "Cooking time (s)") # The relationship with cooking time appears even stronger
```


##### Effect of cooking time on lnRR for each cooking category

```{r, fig.height=8, fig.width=10}
  oil_dat.sens <- filter(dat.sens, Cooking_Category=="oil-based")
  water_dat.sens <- filter(dat.sens, Cooking_Category=="water-based")
  dry_dat.sens <- filter(dat.sens, Cooking_Category=="No liquid")
  
  
  oil_dat_time.sens<-filter(oil_dat.sens, Length_cooking_time_in_s!="NA") 
  water_dat_time.sens<-filter(water_dat.sens, Length_cooking_time_in_s!="NA") 
  dry_dat_time.sens<-filter(dry_dat.sens, Length_cooking_time_in_s!="NA")
  
model_oil_time.sens<-run_model_oil(oil_dat_time.sens, ~Length_cooking_time_in_s) 
model_water_time.sens<-run_model_water(water_dat_time.sens, ~Length_cooking_time_in_s) 
model_dry_time.sens<-run_model_dry(dry_dat_time.sens, ~Length_cooking_time_in_s) 

pred_oil_time.sens<-predict.rma(model_oil_time.sens)
pred_water_time.sens<-predict.rma(model_water_time.sens)
pred_dry_time.sens<-predict.rma(model_dry_time.sens)

oil_dat_time.sens<-mutate(oil_dat_time.sens,
                    ci.lb = pred_oil_time.sens$ci.lb, 
                    ci.ub = pred_oil_time.sens$ci.ub, 
                    fit = pred_oil_time.sens$pred) 

water_dat_time.sens<-mutate(water_dat_time.sens,
                    ci.lb = pred_water_time.sens$ci.lb, 
                    ci.ub = pred_water_time.sens$ci.ub, 
                    fit = pred_water_time.sens$pred) 

dry_dat_time.sens<-mutate(dry_dat_time.sens,
                    ci.lb = pred_dry_time.sens$ci.lb, 
                    ci.ub = pred_dry_time.sens$ci.ub, 
                    fit = pred_dry_time.sens$pred) 

# Actual plot

ggplot(dat.sens,aes(x = Length_cooking_time_in_s, y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=water_dat_time.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=water_dat_time.sens,aes(y = fit), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=oil_dat_time.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=oil_dat_time.sens,aes(y = fit), size = 1.5, col="goldenrod")+  
  
         geom_ribbon(data=dry_dat_time.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.25) +
       geom_line(data=dry_dat_time.sens,aes(y = fit), size = 1.5, col="palegreen3")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "Cooking time (s)", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), 
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))

```
###### Predictions with the full model

```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_time.sens<- run_model_oil(oil_dat.sens, ~ scale(Temperature_in_Celsius) +
                                           Length_cooking_time_in_s+
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))

pred_oil_time.sens<-predict.rma(full_model_oil_time.sens, addx=TRUE, newmods=cbind(0,c(120:1500), 0, 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_oil_time.sens<-as.data.frame(pred_oil_time.sens)
pred_oil_time.sens$Length_cooking_time_in_s=pred_oil_time.sens$X.Length_cooking_time_in_s
pred_oil_time.sens<-left_join(oil_dat.sens, pred_oil_time.sens, by="Length_cooking_time_in_s")


##### Water based
full_model_water_time.sens<- run_model_water(water_dat.sens, ~ scale(Temperature_in_Celsius) +
                                           Length_cooking_time_in_s+
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))

pred_water_time.sens<-predict.rma(full_model_water_time.sens, addx=TRUE, newmods=cbind(c(120:1500), 0, 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_water_time.sens<-as.data.frame(pred_water_time.sens)
pred_water_time.sens$Length_cooking_time_in_s=pred_water_time.sens$X.Length_cooking_time_in_s
pred_water_time.sens<-left_join(water_dat, pred_water_time.sens, by="Length_cooking_time_in_s")

##### No liquid 

full_model_dry_time.sens<- run_model_dry(dry_dat.sens, ~ Length_cooking_time_in_s)

pred_dry_time.sens<-predict.rma(full_model_dry_time.sens, addx=TRUE) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_dry_time.sens<-as.data.frame(pred_dry_time.sens)
pred_dry_time.sens$Length_cooking_time_in_s=pred_dry_time.sens$X.Length_cooking_time_in_s
pred_dry_time.sens<-left_join(dry_dat.sens, pred_dry_time.sens, by="Length_cooking_time_in_s")




ggplot(dat.sens,aes(x = Length_cooking_time_in_s, y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=pred_water_time.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_time.sens,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=pred_oil_time.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=pred_oil_time.sens,aes(y = pred), size = 1.5, col="goldenrod")+  
  
        geom_ribbon(data=pred_dry_time.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_dry_time.sens,aes(y = pred), size = 1.5, col="palegreen3")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "Cooking time (s)", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```



#### Volume of liquid 


```{r, fig.height=8, fig.width=10}
dat.sens.vol<-filter(dat.sens, Volume_liquid_ml!="NA")
include <- row.names(cor_tree) %in% dat.sens.vol$Phylogeny # Check which rows are present in the phylogenetic tree 
cor_tree_sens.vol <- cor_tree[include, include] # Only include the species that match the reduced data set 
VCV_lnRR.sens.vol<-make_VCV_matrix(dat.sens.vol, V = "var_lnRR", cluster = "Cohort_ID", obs = "Effect_ID", rho = 0.5) # create VCV matrix for the specified data


mod.sens.vol<- rma.mv(lnRR, VCV_lnRR.sens.vol, 
         mods=~ log(Volume_liquid_ml),
         random = list(~1|Study_ID,
                       ~1|Phylogeny, 
                       ~1|Species_common, 
                       ~1|PFAS_type, 
                       ~1|Effect_ID), 
         R= list(Phylogeny = cor_tree_sens.vol), 
         test = "t", 
         data = dat.sens.vol)
summary(mod.sens.vol)

plot_continuous(dat.sens.vol, mod.sens.vol, log(dat.sens.vol$Volume_liquid_ml), "ln(Volume of liquid (mL))") # The relationship with cooking time appears even stronger

```

##### Effect of cooking time on lnRR for each cooking category

```{r, fig.height=8, fig.width=10}
  oil_dat.sens <- filter(dat.sens, Cooking_Category=="oil-based")
  water_dat.sens <- filter(dat.sens, Cooking_Category=="water-based")
  dry_dat.sens <- filter(dat.sens, Cooking_Category=="No liquid")
  
  
  oil_dat_vol.sens<-filter(oil_dat.sens, Volume_liquid_ml!="NA") 
  water_dat_vol.sens<-filter(water_dat.sens, Volume_liquid_ml!="NA") 
  dry_dat_vol.sens<-filter(dry_dat.sens, Volume_liquid_ml!="NA")
  
model_oil_vol.sens<-run_model_oil(oil_dat_vol.sens, ~log(Volume_liquid_ml)) 
model_water_vol.sens<-run_model_water(water_dat_vol.sens, ~log(Volume_liquid_ml)) 
model_dry_vol.sens<-run_model_dry(dry_dat_vol.sens, ~log(Volume_liquid_ml)) 

pred_oil_vol.sens<-predict.rma(model_oil_vol.sens)
pred_water_vol.sens<-predict.rma(model_water_vol.sens)
pred_dry_vol.sens<-predict.rma(model_dry_vol.sens)

oil_dat_vol.sens<-mutate(oil_dat_vol.sens,
                    ci.lb = pred_oil_vol.sens$ci.lb, 
                    ci.ub = pred_oil_vol.sens$ci.ub, 
                    fit = pred_oil_vol.sens$pred) 

water_dat_vol.sens<-mutate(water_dat_vol.sens,
                    ci.lb = pred_water_vol.sens$ci.lb, 
                    ci.ub = pred_water_vol.sens$ci.ub, 
                    fit = pred_water_vol.sens$pred) 

dry_dat_vol.sens<-mutate(dry_dat_vol.sens,
                    ci.lb = pred_dry_vol.sens$ci.lb, 
                    ci.ub = pred_dry_vol.sens$ci.ub, 
                    fit = pred_dry_vol.sens$pred) 

# Actual plot

ggplot(dat.sens,aes(x = log(Volume_liquid_ml), y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=water_dat_vol.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=water_dat_vol.sens,aes(y = fit), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=oil_dat_vol.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=oil_dat_vol.sens,aes(y = fit), size = 1.5, col="goldenrod")+  
  
         geom_ribbon(data=dry_dat_vol.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=dry_dat_vol.sens,aes(y = fit), size = 1.5, col="palegreen3")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "ln(Volume of liquid (mL))", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), 
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))

```



##### Predictions with the full model

```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_vol.sens<- run_model_oil(oil_dat.sens, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           scale(PFAS_carbon_chain) +
                                           log_Volume_liquid_ml)
pred_oil_vol.sens<-predict.rma(full_model_oil_vol.sens, addx=TRUE, newmods=cbind(0,0,0, c(log(5):log(750))))# Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time

pred_oil_vol.sens<-as.data.frame(pred_oil_vol.sens)
pred_oil_vol.sens<-pred_oil_vol.sens %>% mutate(Volume_liquid_ml=exp(X.log_Volume_liquid_ml), Cooking_Category="oil-based", lnRR=0) # for the plot to work, we need to add a column with cooking category and a column with lnRR


##### Water based 

full_model_water_vol.sens<- run_model_water(water_dat.sens, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           scale(PFAS_carbon_chain) +
                                           log_Volume_liquid_ml)

pred_water_vol.sens<-predict.rma(full_model_water_vol.sens, addx=TRUE, newmods=cbind(0,0, c(5.521461:7.824046)))# Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time

pred_water_vol.sens<-as.data.frame(pred_water_vol.sens)
pred_water_vol.sens<-pred_water_vol.sens %>% mutate(Volume_liquid_ml=exp(X.log_Volume_liquid_ml), Cooking_Category="water-based", lnRR=0)



ggplot(dat.sens,aes(x = log(Volume_liquid_ml), y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=pred_water_vol.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_vol.sens,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=pred_oil_vol.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=pred_oil_vol.sens,aes(y = pred), size = 1.5, col="goldenrod")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF","goldenrod2", "dodgerblue3"))+
       labs(x = "ln(Volume of liquid (mL))", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), 
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2)) #### The line doesn't go all the way down (the predict function doesn't capture the biggest values)

```

#### PFAS carbon chain 

```{r, fig.width=9, fig.height=7}
dat.sens.PFAS<-filter(dat.sens, PFAS_carbon_chain!="NA")
include <- row.names(cor_tree) %in% dat.sens.PFAS$Phylogeny # Check which rows are present in the phylogenetic tree 
cor_tree_sens.PFAS <- cor_tree[include, include] # Only include the species that match the reduced data set 
VCV_lnRR.sens.PFAS<-make_VCV_matrix(dat.sens.PFAS, V = "var_lnRR", cluster = "Cohort_ID", obs = "Effect_ID", rho = 0.5) # create VCV matrix for the specified data


mod.sens.PFAS<- rma.mv(lnRR, VCV_lnRR.sens.PFAS, 
         mods=~ PFAS_carbon_chain,
         random = list(~1|Study_ID,
                       ~1|Phylogeny, 
                       ~1|Species_common, 
                       ~1|PFAS_type, 
                       ~1|Effect_ID), 
         R= list(Phylogeny = cor_tree_sens.PFAS), 
         test = "t", 
         data = dat.sens.PFAS)
summary(mod.sens.PFAS)

plot_continuous(dat.sens.PFAS, mod.sens.PFAS, dat.sens.PFAS$PFAS_carbon_chain, "PFAS carbon chain length") # The relationship with cooking time appears even stronger

```


##### Effect of carbon chain length on lnRR for each cooking category

```{r, fig.height=8, fig.width=10}
  oil_dat.sens <- filter(dat.sens, Cooking_Category=="oil-based")
  water_dat.sens <- filter(dat.sens, Cooking_Category=="water-based")
  dry_dat.sens <- filter(dat.sens, Cooking_Category=="No liquid")
  
  
  oil_dat_PFAS.sens<-filter(oil_dat.sens, PFAS_carbon_chain!="NA") 
  water_dat_PFAS.sens<-filter(water_dat.sens, PFAS_carbon_chain!="NA") 
  dry_dat_PFAS.sens<-filter(dry_dat.sens, PFAS_carbon_chain!="NA")
  
model_oil_PFAS.sens<-run_model_oil(oil_dat_PFAS.sens, ~PFAS_carbon_chain) 
model_water_PFAS.sens<-run_model_water(water_dat_PFAS.sens, ~PFAS_carbon_chain)
model_dry_PFAS.sens<-run_model_dry(dry_dat_PFAS.sens, ~PFAS_carbon_chain)

pred_oil_PFAS.sens<-predict.rma(model_oil_PFAS.sens)
pred_water_PFAS.sens<-predict.rma(model_water_PFAS.sens)
pred_dry_PFAS.sens<-predict.rma(model_dry_PFAS.sens)

oil_dat_PFAS.sens<-mutate(oil_dat_PFAS.sens,
                    ci.lb = pred_oil_PFAS.sens$ci.lb, 
                    ci.ub = pred_oil_PFAS.sens$ci.ub, 
                    fit = pred_oil_PFAS.sens$pred) 

water_dat_PFAS.sens<-mutate(water_dat_PFAS.sens,
                    ci.lb = pred_water_PFAS.sens$ci.lb, 
                    ci.ub = pred_water_PFAS.sens$ci.ub, 
                    fit = pred_water_PFAS.sens$pred) 

dry_dat_PFAS.sens<-mutate(dry_dat_PFAS.sens,
                    ci.lb = pred_dry_PFAS.sens$ci.lb, 
                    ci.ub = pred_dry_PFAS.sens$ci.ub, 
                    fit = pred_dry_PFAS.sens$pred) 

# Actual plot

ggplot(dat.sens,aes(x = PFAS_carbon_chain, y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=dry_dat_PFAS.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=dry_dat_PFAS.sens,aes(y = fit), size = 1.5, col="palegreen3")+  
  
       geom_ribbon(data=oil_dat_PFAS.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=oil_dat_PFAS.sens,aes(y = fit), size = 1.5, col="goldenrod")+  

        geom_ribbon(data=water_dat_PFAS.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=water_dat_PFAS.sens,aes(y = fit), size = 1.5, col="dodgerblue")+  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "PFAS carbon chain length", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), 
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))

```

##### Predictions with the full model

```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_PFAS.sens<- run_model_oil(oil_dat.sens, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           PFAS_carbon_chain +
                                           scale(log(Volume_liquid_ml)))
pred_oil_PFAS.sens<-predict.rma(full_model_oil_PFAS.sens, addx=TRUE, newmods=cbind(0,0, c(3:14),0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of PFAS carbon chain
pred_oil_PFAS.sens<-as.data.frame(pred_oil_PFAS.sens)
pred_oil_PFAS.sens$PFAS_carbon_chain=pred_oil_PFAS.sens$X.PFAS_carbon_chain
pred_oil_PFAS.sens<-left_join(oil_dat.sens, pred_oil_PFAS.sens, by="PFAS_carbon_chain")


##### Water based
full_model_water_PFAS.sens<- run_model_water(water_dat.sens, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           PFAS_carbon_chain +
                                           scale(log(Volume_liquid_ml)))

pred_water_PFAS.sens<-predict.rma(full_model_water_PFAS.sens, addx=TRUE, newmods=cbind(0, c(3:14),0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_water_PFAS.sens<-as.data.frame(pred_water_PFAS.sens)
pred_water_PFAS.sens$PFAS_carbon_chain=pred_water_PFAS.sens$X.PFAS_carbon_chain
pred_water_PFAS.sens<-left_join(water_dat.sens, pred_water_PFAS.sens, by="PFAS_carbon_chain")

##### No liquid 

full_model_dry_PFAS.sens<- run_model_dry(dry_dat.sens, ~ PFAS_carbon_chain)

pred_dry_PFAS.sens<-predict.rma(full_model_dry_PFAS.sens, addx=TRUE)
pred_dry_PFAS.sens<-as.data.frame(pred_dry_PFAS.sens)
pred_dry_PFAS.sens$PFAS_carbon_chain=pred_dry_PFAS.sens$X.PFAS_carbon_chain
pred_dry_PFAS.sens<-left_join(dry_dat.sens, pred_dry_PFAS.sens, by="PFAS_carbon_chain")



ggplot(dat.sens,aes(x = PFAS_carbon_chain, y = lnRR, fill=Cooking_Category)) +
  
    
       geom_ribbon(data=pred_dry_PFAS.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_dry_PFAS.sens,aes(y = pred), size = 1.5, col="palegreen3")+  
  
  
       geom_ribbon(data=pred_water_PFAS.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_PFAS.sens,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
  
       geom_ribbon(data=pred_oil_PFAS.sens, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=pred_oil_PFAS.sens,aes(y = pred), size = 1.5, col="goldenrod")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "PFAS carbon chain length", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```



#### Funnel plot 

```{r, fig.width=8, fig.height=7}
full_mod.sens<-run_model(dat.sens, ~ -1 +  Cooking_Category  + 
                                scale(Temperature_in_Celsius) + 
                                scale(Length_cooking_time_in_s) + 
                                scale(PFAS_carbon_chain) + 
                                scale(log(Volume_liquid_ml)))


funnel(full_mod.sens, yaxis="seinv")
```


##


# **Figures for publication** 


## Figure 2 

```{r}
run_model(dat, ~-1 + Cooking_Category + I(sqrt(1/N_tilde)) + scale(Publication_year) + 
    scale(Temperature_in_Celsius) + scale(Length_cooking_time_in_s) + scale(PFAS_carbon_chain) + 
    scale(log(Volume_liquid_ml)))
```

### Cooking time


```{r, fig.width=9, fig.height=7}
full_model_time<- run_model(dat, ~     scale(Temperature_in_Celsius) +
                                       Length_cooking_time_in_s+
                                       scale(PFAS_carbon_chain) +
                                       scale(log(Volume_liquid_ml)))

pred_full_model_time<-predict.rma(full_model_time, addx=TRUE, newmods=cbind(0,c(120:1500), 0, 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_full_model_time<-as.data.frame(pred_full_model_time)
pred_full_model_time$Length_cooking_time_in_s=pred_full_model_time$X.Length_cooking_time_in_s
pred_full_model_time<-left_join(dat, pred_full_model_time, by="Length_cooking_time_in_s")



uni_model_time<- run_model(dat, ~ Length_cooking_time_in_s)

pred_uni_model_time<-predict.rma(uni_model_time, addx=TRUE) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_uni_model_time<-as.data.frame(pred_uni_model_time)
pred_uni_model_time$Length_cooking_time_in_s=pred_uni_model_time$X.Length_cooking_time_in_s
pred_uni_model_time<-left_join(dat, pred_uni_model_time, by="Length_cooking_time_in_s")



p_time<-ggplot(dat,aes(x = Length_cooking_time_in_s, y = lnRR)) +
  
       geom_point(aes(size=(1/sqrt(var_lnRR))), shape=21, alpha=0.8, fill="gray75") +
  
       geom_ribbon(data=pred_full_model_time, aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.25, fill="orangered") +
       geom_line(data=pred_full_model_time,aes(y = pred), size = 1.5, color="orangered2")+  
  
       geom_ribbon(data=pred_uni_model_time, aes(ymin = ci.lb, ymax = ci.ub), alpha=0.25, fill="gray40") +
       geom_line(data=pred_uni_model_time,aes(y = pred), size = 1.5, col="gray30")+  
  
       labs(x = "Cooking time (s)", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.position="none",
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```


### Volume of liquid 


```{r, fig.width=9, fig.height=7}
full_model_vol<- run_model(dat, ~      scale(Temperature_in_Celsius) +
                                       scale(Length_cooking_time_in_s)+
                                       scale(PFAS_carbon_chain) +
                                       log_Volume_liquid_ml)

pred_full_model_vol<-predict.rma(full_model_vol, addx=TRUE, newmods=cbind(0,0, 0, c(log(5):log(59777))))
pred_full_model_vol<-as.data.frame(pred_full_model_vol)
pred_full_model_vol$log_Volume_liquid_ml=pred_full_model_vol$X.log_Volume_liquid_ml
pred_full_model_vol<- pred_full_model_vol %>% mutate(Volume_liquid_ml = exp(X.log_Volume_liquid_ml), lnRR = 0) 



uni_model_vol<- run_model(dat, ~ log_Volume_liquid_ml)

pred_uni_model_vol<-predict.rma(uni_model_vol, addx=TRUE) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_uni_model_vol<-as.data.frame(pred_uni_model_vol)
pred_uni_model_vol$log_Volume_liquid_ml=pred_uni_model_vol$X.log_Volume_liquid_ml
pred_uni_model_vol<- pred_uni_model_vol %>% mutate(Volume_liquid_ml = exp(X.log_Volume_liquid_ml), lnRR = 0) 



p_vol<-ggplot(dat,aes(x = log_Volume_liquid_ml, y = lnRR)) +
  
       geom_point(aes(size=(1/sqrt(var_lnRR))), shape=21, alpha=0.8, fill="gray75") +
  
       geom_ribbon(data=pred_full_model_vol, aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.25, fill="orangered") +
       geom_line(data=pred_full_model_vol,aes(y = pred), size = 1.5, color="orangered2")+  
  
       geom_ribbon(data=pred_uni_model_vol, aes(ymin = ci.lb, ymax = ci.ub), alpha=0.25, fill="gray40") +
       geom_line(data=pred_uni_model_vol,aes(y = pred), size = 1.5, col="gray30")+  
  
       labs(x = "ln[Volume of liquid (mL)]", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.position="none", 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```


### Cooking temperature

```{r, fig.width=9, fig.height=7}
full_model_temp<- run_model(dat, ~     Temperature_in_Celsius +
                                       scale(Length_cooking_time_in_s)+
                                       scale(PFAS_carbon_chain) +
                                       scale(log(Volume_liquid_ml)))

pred_full_model_temp<-predict.rma(full_model_temp, addx=TRUE, newmods=cbind(c(75:300),0, 0, 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_full_model_temp<-as.data.frame(pred_full_model_temp)
pred_full_model_temp$Temperature_in_Celsius=pred_full_model_temp$X.Temperature_in_Celsius
pred_full_model_temp<-left_join(dat, pred_full_model_temp, by="Temperature_in_Celsius")



uni_model_temp<- run_model(dat, ~ Temperature_in_Celsius)

pred_uni_model_temp<-predict.rma(uni_model_temp, addx=TRUE) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_uni_model_temp<-as.data.frame(pred_uni_model_temp)
pred_uni_model_temp$Temperature_in_Celsius=pred_uni_model_temp$X.Temperature_in_Celsius
pred_uni_model_temp<-left_join(dat, pred_uni_model_temp, by="Temperature_in_Celsius")



p_temp<-ggplot(dat,aes(x = Temperature_in_Celsius, y = lnRR)) +
  
       geom_point(aes(size=(1/sqrt(var_lnRR))), shape=21, alpha=0.8, fill="gray75") +
  
       geom_ribbon(data=pred_full_model_temp, aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.25, fill="orangered") +
       geom_line(data=pred_full_model_temp,aes(y = pred), size = 1.5, color="orangered2")+  
  
       geom_ribbon(data=pred_uni_model_temp, aes(ymin = ci.lb, ymax = ci.ub), alpha=0.25, fill="gray40") +
       geom_line(data=pred_uni_model_temp,aes(y = pred), size = 1.5, col="gray30")+  
  
       labs(x = "Cooking temperature (C)", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(1,0), 
          legend.justification = c(1,0),
          legend.background = element_blank(), 
          legend.direction="vertical",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```


### PFAS carbon chain length 


```{r, fig.width=9, fig.height=7}
full_model_PFAS<- run_model(dat, ~     scale(Temperature_in_Celsius) +
                                       scale(Length_cooking_time_in_s)+
                                       PFAS_carbon_chain +
                                       scale(log(Volume_liquid_ml)))

pred_full_model_PFAS<-predict.rma(full_model_PFAS, addx=TRUE, newmods=cbind(0, 0, c(3:14), 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_full_model_PFAS<-as.data.frame(pred_full_model_PFAS)
pred_full_model_PFAS$PFAS_carbon_chain=pred_full_model_PFAS$X.PFAS_carbon_chain
pred_full_model_PFAS<-left_join(dat, pred_full_model_PFAS, by="PFAS_carbon_chain")



uni_model_PFAS<- run_model(dat, ~ PFAS_carbon_chain)

pred_uni_model_PFAS<-predict.rma(uni_model_PFAS, addx=TRUE) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_uni_model_PFAS<-as.data.frame(pred_uni_model_PFAS)
pred_uni_model_PFAS$PFAS_carbon_chain=pred_uni_model_PFAS$X.PFAS_carbon_chain
pred_uni_model_PFAS<-left_join(dat, pred_uni_model_PFAS, by="PFAS_carbon_chain")



p_PFAS<-ggplot(dat,aes(x = PFAS_carbon_chain, y = lnRR)) +
  
       geom_point(aes(size=(1/sqrt(var_lnRR))), shape=21, alpha=0.8, fill="gray75") +
  
       geom_ribbon(data=pred_full_model_PFAS, aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.25, fill="orangered") +
       geom_line(data=pred_full_model_PFAS,aes(y = pred), size = 1.5, color="orangered2")+  
  
       geom_ribbon(data=pred_uni_model_PFAS, aes(ymin = ci.lb, ymax = ci.ub), alpha=0.25, fill="gray40") +
       geom_line(data=pred_uni_model_PFAS,aes(y = pred), size = 1.5, col="gray30")+  
  
       labs(x = "PFAS carbon chain length", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.position="none",
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```
### Combine plots and save

```{r, fig.width=15, fig.height=12, eval=F}
(p_time+p_vol)/(p_temp+p_PFAS) + plot_annotation(tag_levels=c('A', 'B', 'C', 'D'))

ggsave("fig/Fig_2.png", width=15, height=12, dpi=1200)
```

## Figure 3 

### Adapt orchard_plot function 

```{r}
my_orchard<-function (object, mod = "Int", xlab, N = "none", 
    alpha = 0.5, angle = 90, cb = FALSE, k = TRUE, transfm = c("none", 
        "tanh"), condition.lab = "Condition") 
{
    transfm <- match.arg(transfm)
    if (any(class(object) %in% c("rma.mv", "rma"))) {
        if (mod != "Int") {
            object <- mod_results(object, mod)
        }
        else {
            object <- mod_results(object, mod = "Int")
        }
    }
    mod_table <- object$mod_table
    data <- object$data
    data$moderator <- factor(data$moderator, levels = mod_table$name, 
        labels = mod_table$name)
    data$scale <- (1/sqrt(data[, "vi"]))
    legend <- "Precision (1/SE)"
    if (any(N != "none")) {
        data$scale <- N
        legend <- "Sample Size (N)"
    }
    if (transfm == "tanh") {
        cols <- sapply(mod_table, is.numeric)
        mod_table[, cols] <- Zr_to_r(mod_table[, cols])
        data$yi <- Zr_to_r(data$yi)
        label <- xlab
    }
    else {
        label <- xlab
    }
    mod_table$K <- as.vector(by(data, data[, "moderator"], 
        function(x) length(x[, "yi"])))
    group_no <- length(unique(mod_table[, "name"]))
    cbpl <- c("#55C667FF", "goldenrod2", "dodgerblue3") # change colors
    if (names(mod_table)[2] == "condition") {
        condition_no <- length(unique(mod_table[, "condition"]))
        plot <- ggplot2::ggplot() + ggbeeswarm::geom_quasirandom(data = data, 
            ggplot2::aes(y = yi, x = moderator, size = scale, 
                color = moderator), alpha = alpha) + ggplot2::geom_hline(yintercept = 0, 
            linetype = 2, colour = "black", alpha = alpha) + 
            ggplot2::geom_linerange(data = mod_table, ggplot2::aes(x = name, 
                ymin = lowerPR, ymax = upperPR), size = 0.75, # change size confidence intervals and swap CL with PR. Added whiskers
                position = ggplot2::position_dodge2(width = 0.3)) + 
            ggplot2::geom_pointrange(data = mod_table, ggplot2::aes(y = estimate, 
                x = name, ymin = lowerCL, ymax = upperCL, shape = as.factor(condition), # swap CL with PR
                fill = name), size = 1.6, stroke=2.2, width= 1.3, position = ggplot2::position_dodge2(width = 0.3)) + # change size point and prediction intervals
            ggplot2::scale_shape_manual(values = 20 + (1:condition_no)) + 
            ggplot2::coord_flip() + ggplot2::theme_bw() + ggplot2::guides(fill = "none", 
            colour = "none") + ggplot2::theme(legend.position = c(0, 
            1), legend.justification = c(0, 1)) + ggplot2::theme(legend.title = ggplot2::element_text(size = 9)) + 
            ggplot2::theme(legend.direction = "horizontal") + 
            ggplot2::theme(legend.background = ggplot2::element_blank()) + 
            ggplot2::labs(y = label, x = "", size = legend) + 
            ggplot2::labs(shape = condition.lab) + ggplot2::theme(axis.text.y = ggplot2::element_text(size = 10, 
            colour = "black", hjust = 0.5, angle = angle))
        plot <- plot + ggplot2::annotate("text", y = (max(data$yi) + 
            (max(data$yi) * 0.1)), x = (seq(1, group_no, 1) + 
            0.3), label = paste("italic(k)==", mod_table$K[1:group_no]), 
            parse = TRUE, hjust = "right", size = 3.5)
    }
    else {
        plot <- ggplot2::ggplot(data = mod_table, ggplot2::aes(x = estimate, 
            y = name)) + ggbeeswarm::geom_quasirandom(data = data, 
            ggplot2::aes(x = yi, y = moderator, size = scale, 
                colour = moderator), groupOnX = FALSE, alpha = alpha) + 
            ggplot2::geom_errorbarh(ggplot2::aes(xmin = lowerPR, 
                xmax = upperPR), height = 0, show.legend = FALSE, # change error barrs
                size = 0.75, alpha = 0.5) + ggplot2::geom_errorbarh(ggplot2::aes(xmin = lowerCL, 
            xmax = upperCL), height = 0.1, show.legend = FALSE, 
            size = 1.75) + ggplot2::geom_vline(xintercept = 0, 
            linetype = 2, colour = "black", alpha = alpha) + 
            ggplot2::geom_point(ggplot2::aes(fill = name), size = 8,  # change point size
                shape = 21) + ggplot2::theme_bw() + ggplot2::guides(fill = "none", 
            colour = "none") + ggplot2::theme(legend.position = c(1, 
            0), legend.justification = c(1, 0)) + ggplot2::theme(legend.title = ggplot2::element_text(size = 9)) + 
            ggplot2::theme(legend.direction = "horizontal") + 
            ggplot2::theme(legend.background = ggplot2::element_blank()) + 
            ggplot2::labs(x = label, y = "", size = legend) + 
            ggplot2::theme(axis.text.y = ggplot2::element_text(size = 10, 
                colour = "black", hjust = 0.5, angle = angle))
        if (k == TRUE) {
            plot <- plot + ggplot2::annotate("text", x = (max(data$yi) + 
                (max(data$yi) * 0.1)), y = (seq(1, group_no, 
                1) + 0.3), label = paste("italic(k)==", 
                mod_table$K), parse = TRUE, hjust = "right", 
                size = 3.5)
        }
    }
    if (cb == TRUE) {
        plot <- plot + ggplot2::scale_fill_manual(values = cbpl) + 
            ggplot2::scale_colour_manual(values = cbpl)
    }
    return(plot)
}
```

### Run full models in original units

```{r}
full_model_org_units <- run_model(dat, ~ - 1 + 
                               Cooking_Category +
                               Temperature_in_Celsius +
                               Length_cooking_time_in_s +
                               PFAS_carbon_chain +
                               log_Volume_liquid_ml)

# full model without the "No liquid" data for figure 3B. 
full_model_org_units_oil_water <- run_model(dat_oil_water, ~ - 1 +
                               Cooking_Category +
                               Temperature_in_Celsius +
                               Length_cooking_time_in_s +
                               PFAS_carbon_chain +
                               log_Volume_liquid_ml)
```


### Figure 3A

Estimates at cooking times of 2, 10 and 25 min
```{r, fig.height=5, fig.width=7}
time_mm <-marginal_means(full_model_org_units, data = dat, mod = "1", at = list(Length_cooking_time_in_s = c(120,600,1500)), by = "Length_cooking_time_in_s")
 
p_time_mm<-my_orchard(time_mm, xlab = "lnRR", condition.lab = "Cooking time (sec)", alpha=0.3)+
           scale_size_continuous(range = c(1, 10))+
           scale_fill_manual(values="sienna2")+
           scale_colour_manual(values = "sienna2")+ # change colours
           theme(panel.border = element_rect(colour = "black", fill=NA, size=1.3), # border around the plot
                 text = element_text(size = 24), # change font sizes
                 legend.title = element_text(size = 13),
                 legend.text = element_text(size = 10),
                 legend.position = c(0,0.28))
```

#### Figure 3B

Estimates at volumes of liquid of ~10, 500, and 10000 mL
```{r, fig.height=5, fig.width=7}
volume_mm <-marginal_means(full_model_org_units_oil_water, data = dat_oil_water, mod = "1", at = list(log_Volume_liquid_ml= c(2.3, 6.2, 9.2)), by = "log_Volume_liquid_ml")
 
p_volume_mm<-my_orchard(volume_mm, xlab = "lnRR", condition.lab = "ln(liquid volume (mL))", alpha=0.3)+
           scale_size_continuous(range = c(1, 10))+
           scale_fill_manual(values="deepskyblue2")+
           scale_colour_manual(values = "deepskyblue2")+ # change colours
           theme(panel.border = element_rect(colour = "black", fill=NA, size=1.3), # border around the plot
                 text = element_text(size = 24), # change font sizes
                 legend.title = element_text(size = 13),
                 legend.text = element_text(size = 10),
                 legend.position = c(0,0.28))
```



### Figure 3C 


Estimates at cooking times of 2, 10 and 25 min

```{r, fig.height=10, fig.width=8}

time_mm_cat <- marginal_means(full_model_org_units, data = dat, mod = "Cooking_Category", at = list(Length_cooking_time_in_s = c(120,600,1500)), by = "Length_cooking_time_in_s")
 
p_time_mm_cat<-my_orchard(time_mm_cat, xlab = "lnRR", condition.lab  = "Cooking time (sec)", alpha=0.3)+
           scale_size_continuous(range = c(1, 10))+
           scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
           scale_colour_manual(values = c("#55C667FF", "goldenrod2", "dodgerblue3"))+ # change colours
           theme(panel.border = element_rect(colour = "black", fill=NA, size=1.3), # border around the plot
                 text = element_text(size = 24), # change font sizes
                 legend.title = element_text(size = 13),
                 legend.text = element_text(size = 10),
                 legend.position = c(0,0.12))
```

### Combine plots and save

```{r, fig.height=10, fig.width=14}
((p_time_mm/p_volume_mm)|p_time_mm_cat) + plot_annotation(tag_levels=c("A", "B", "C"))

ggsave("fig/Fig_3.png", width=14, height=10, dpi=1200)
```


## Figure 4

### Figure 4A 

```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_time<- run_model_oil(oil_dat, ~ scale(Temperature_in_Celsius) +
                                           Length_cooking_time_in_s+
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))

pred_oil_time<-predict.rma(full_model_oil_time, addx=TRUE, newmods=cbind(0,c(120:1500), 0, 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_oil_time<-as.data.frame(pred_oil_time)
pred_oil_time$Length_cooking_time_in_s=pred_oil_time$X.Length_cooking_time_in_s
pred_oil_time<-left_join(oil_dat, pred_oil_time, by="Length_cooking_time_in_s")


##### Water based
full_model_water_time<- run_model_water(water_dat, ~ scale(Temperature_in_Celsius) +
                                           Length_cooking_time_in_s+
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))

pred_water_time<-predict.rma(full_model_water_time, addx=TRUE, newmods=cbind(c(120:1500), 0, 0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_water_time<-as.data.frame(pred_water_time)
pred_water_time$Length_cooking_time_in_s=pred_water_time$X.Length_cooking_time_in_s
pred_water_time<-left_join(water_dat, pred_water_time, by="Length_cooking_time_in_s")

##### No liquid 

full_model_dry_time<- run_model_dry(dry_dat, ~ Length_cooking_time_in_s)

pred_dry_time<-predict.rma(full_model_dry_time, addx=TRUE) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_dry_time<-as.data.frame(pred_dry_time)
pred_dry_time$Length_cooking_time_in_s=pred_dry_time$X.Length_cooking_time_in_s
pred_dry_time<-left_join(dry_dat, pred_dry_time, by="Length_cooking_time_in_s")




p_4A<-ggplot(dat,aes(x = Length_cooking_time_in_s, y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=pred_water_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_time,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=pred_oil_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_oil_time,aes(y = pred), size = 1.5, col="goldenrod")+  
  
        geom_ribbon(data=pred_dry_time, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_dry_time,aes(y = pred), size = 1.5, col="palegreen3")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "Cooking time (s)", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position="none",
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```

### Figure 4B 


```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_vol<- run_model_oil(oil_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           scale(PFAS_carbon_chain) +
                                           log_Volume_liquid_ml)
pred_oil_vol<-predict.rma(full_model_oil_vol, addx=TRUE, newmods=cbind(0,0,0, c(log(5):log(750))))# Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time

pred_oil_vol<-as.data.frame(pred_oil_vol)
pred_oil_vol<-pred_oil_vol %>% mutate(Volume_liquid_ml=exp(X.log_Volume_liquid_ml), Cooking_Category="oil-based", lnRR=0) # for the plot to work, we need to add a column with cooking category and a column with lnRR


##### Water based 

full_model_water_vol<- run_model_water(water_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           scale(PFAS_carbon_chain) +
                                           log_Volume_liquid_ml)

pred_water_vol<-predict.rma(full_model_water_vol, addx=TRUE, newmods=cbind(0,0, c(log(250):log(59777))))# Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time

pred_water_vol<-as.data.frame(pred_water_vol)
pred_water_vol<-pred_water_vol %>% mutate(Volume_liquid_ml=exp(X.log_Volume_liquid_ml), Cooking_Category="water-based", lnRR=0)



p_4B<- ggplot(dat,aes(x = log(Volume_liquid_ml), y = lnRR, fill=Cooking_Category)) +
  
       geom_ribbon(data=pred_water_vol, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_vol,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
       geom_ribbon(data=pred_oil_vol, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=pred_oil_vol,aes(y = pred), size = 1.5, col="goldenrod")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF","goldenrod2", "dodgerblue3"))+
       labs(x = "ln(Volume of liquid (mL))", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), 
          legend.text=element_text(size=14),
          legend.position="none",
          panel.border=element_rect(colour="black", fill=NA, size=1.2)) #### The line doesn't go all the way down for water-based because the highest values are not included in the full model

```


### Figure 4C 

```{r, fig.height=8, fig.width=10}

full_model_oil_temp<- run_model_oil(oil_dat, ~ Temperature_in_Celsius +
                                           scale(Length_cooking_time_in_s)+
                                           scale(PFAS_carbon_chain) +
                                           scale(log(Volume_liquid_ml)))
pred_oil_temp<-predict.rma(full_model_oil_temp, addx=TRUE, newmods=cbind(c(75:300),0, 0,0)) 
pred_oil_temp<-as.data.frame(pred_oil_temp)
pred_oil_temp$Temperature_in_Celsius=pred_oil_temp$X.Temperature_in_Celsius
pred_oil_temp<-left_join(oil_dat, pred_oil_temp, by="Temperature_in_Celsius")



p_4C<-ggplot(dat,aes(x = Temperature_in_Celsius, y = lnRR, fill=Cooking_Category)) +
    
       geom_ribbon(data=pred_oil_temp, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=pred_oil_temp,aes(y = pred), size = 1.5, col="goldenrod")+  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "Cooking temperature (C)", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(1,0), 
          legend.justification = c(1,0),
          legend.background = element_blank(), 
          legend.direction="vertical",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```


### Figure 4D 


```{r, fig.height=8, fig.width=10}
##### Oil based
full_model_oil_PFAS<- run_model_oil(oil_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           PFAS_carbon_chain +
                                           scale(log(Volume_liquid_ml)))
pred_oil_PFAS<-predict.rma(full_model_oil_PFAS, addx=TRUE, newmods=cbind(0,0, c(3:14),0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of PFAS carbon chain
pred_oil_PFAS<-as.data.frame(pred_oil_PFAS)
pred_oil_PFAS$PFAS_carbon_chain=pred_oil_PFAS$X.PFAS_carbon_chain
pred_oil_PFAS<-left_join(oil_dat, pred_oil_PFAS, by="PFAS_carbon_chain")


##### Water based
full_model_water_PFAS<- run_model_water(water_dat, ~ scale(Temperature_in_Celsius) +
                                           scale(Length_cooking_time_in_s)+
                                           PFAS_carbon_chain +
                                           scale(log(Volume_liquid_ml)))

pred_water_PFAS<-predict.rma(full_model_water_PFAS, addx=TRUE, newmods=cbind(0, c(3:14),0)) # Set all predictors to their mean (mean =0 when z-transformed) and set the range of values of cooking time
pred_water_PFAS<-as.data.frame(pred_water_PFAS)
pred_water_PFAS$PFAS_carbon_chain=pred_water_PFAS$X.PFAS_carbon_chain
pred_water_PFAS<-left_join(water_dat, pred_water_PFAS, by="PFAS_carbon_chain")

##### No liquid 

full_model_dry_PFAS<- run_model_dry(dry_dat, ~ PFAS_carbon_chain)

pred_dry_PFAS<-predict.rma(full_model_dry_PFAS, addx=TRUE)
pred_dry_PFAS<-as.data.frame(pred_dry_PFAS)
pred_dry_PFAS$PFAS_carbon_chain=pred_dry_PFAS$X.PFAS_carbon_chain
pred_dry_PFAS<-left_join(dry_dat, pred_dry_PFAS, by="PFAS_carbon_chain")




p_4D<-ggplot(dat,aes(x = PFAS_carbon_chain, y = lnRR, fill=Cooking_Category)) +
  
    
       geom_ribbon(data=pred_dry_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_dry_PFAS,aes(y = pred), size = 1.5, col="palegreen3")+  
  
  
       geom_ribbon(data=pred_water_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.2) +
       geom_line(data=pred_water_PFAS,aes(y = pred), size = 1.5, col="dodgerblue")+  
  
  
       geom_ribbon(data=pred_oil_PFAS, aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = 0.3) +
       geom_line(data=pred_oil_PFAS,aes(y = pred), size = 1.5, col="goldenrod")+  
  
  
       geom_point(aes(size=(1/sqrt(var_lnRR)), fill=Cooking_Category), shape=21, alpha=0.8) +
       scale_fill_manual(values=c("#55C667FF", "goldenrod2", "dodgerblue3"))+
       labs(x = "PFAS carbon chain length", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position="none",
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```


### Combine and save
```{r, fig.width=15, fig.height=12}

(p_4A+p_4B)/(p_4C+p_4D)+ plot_annotation(tag_levels=c("A", "B", "C", "D"))

ggsave("fig/Fig_4.png", width=15, height=12, dpi=1200)
```




## Figure 5 

### Figure 5A 

```{r, fig.width=7, fig.height=9}
dat$Study_ID<- as.factor(dat$Study_ID)

funnel(full_model, 
      yaxis="seinv", # Inverse of standard error (precision) as the y axis
      level = c(90, 95, 99),  # levels of statistical significance highlighted 
      shade = c("white", "gray75", "gray55", "gray40"), # shades for different levels of statistical significance
      legend = TRUE, # display legend
      ylab="Precision (1/SE)", 
      cex.lab=1.75, 
      digits=1, 
      ylim=c(1,1.2),
      cex=2,
      pch=21,
      col=dat$Study_ID)

p_5A <-funnel(full_model, 
      yaxis="seinv", # Inverse of standard error (precision) as the y axis
      level = c(90, 95, 99),  # levels of statistical significance highlighted 
      shade = c("white", "gray75", "gray55", "gray40"), # shades for different levels of statistical significance
      legend = TRUE, # display legend
      ylab="Precision (1/SE)", 
      cex.lab=1.75, 
      digits=1, 
      ylim=c(1,1.2),
      cex=2,
      pch=21,
      col=dat$Study_ID)

```

### Figure 5B 

```{r, fig.width=9, fig.height=7}
full_model_egger <- run_model(dat, ~ - 1 +
                      I(sqrt(1/N_tilde)) +  
                      scale(Publication_year) + 
                      scale(Temperature_in_Celsius) +
                      scale(Length_cooking_time_in_s) +
                      scale(PFAS_carbon_chain) +
                      scale(log(Volume_liquid_ml))) # Model to get predictions


pred_egger<-predict.rma(full_model_egger, addx=TRUE, newmods=cbind(c(0.1825742:1.414214),0,0,0 ,0, 0)) 
pred_egger<-as.data.frame(pred_egger)
pred_egger$SE_eff_N=pred_egger$X.I.sqrt.1.N_tilde..
pred_egger<- pred_egger %>% mutate(N_tilde = ((1/X.I.sqrt.1.N_tilde..)^2), lnRR = 0) 

p_5B<-ggplot(dat,aes(x = sqrt(1/N_tilde), y = lnRR)) +
  
       geom_point(aes(size=(1/sqrt(var_lnRR))), shape=21, alpha=0.8, fill="gray75") +
  
       geom_ribbon(data=pred_egger, aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.25, fill="orangered") +
       geom_line(data=pred_egger,aes(y = pred), size = 1.5, color="orangered2")+  

       labs(x = "Standard error", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 20, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.position="none",
          panel.border=element_rect(colour="black", fill=NA, size=1.2))+
  xlim(0.18,1.19)
```


### Figure 5C 


```{r, fig.width=9, fig.height=7}
full_model_pub <- run_model(dat, ~ - 1 +
                      scale(I(sqrt(1/N_tilde))) +  
                      Publication_year + 
                      scale(Temperature_in_Celsius) +
                      scale(Length_cooking_time_in_s) +
                      scale(PFAS_carbon_chain) +
                      scale(log(Volume_liquid_ml))) # Model to get predictions


pred_pub<-predict.rma(full_model_pub, addx=TRUE, newmods=cbind(0,c(2008:2020),0,0 ,0, 0)) 
pred_pub<-as.data.frame(pred_pub)
pred_pub$Publication_year=pred_pub$X.Publication_year
pred_pub<-left_join(dat, pred_pub, by="Publication_year")



p_5C<-ggplot(dat,aes(x = Publication_year, y = lnRR)) +
  
       geom_point(aes(size=(1/sqrt(var_lnRR))), shape=21, alpha=0.8, fill="gray75") +
  
       geom_ribbon(data=pred_pub, aes(ymin = ci.lb, ymax = ci.ub), alpha = 0.25, fill="orangered") +
       geom_line(data=pred_pub,aes(y = pred), size = 1.5, color="orangered2")+  

       labs(x = "Publication year", y = "lnRR", size = "Precison (1/SE)") + 
  scale_size_continuous(range=c(1,10))+
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 20, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(1,0), 
          legend.justification = c(1,0),
          legend.background = element_blank(), 
          legend.direction="vertical",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))  +
   scale_x_continuous(breaks=c(2008, 2010, 2012, 2014, 2016, 2018 ,2020))

```

### Combine and save

For some reason I cannot save the funnel plot. This will be manually copied from the Rmd

```{r, fig.width=18, fig.height=7}
(ggdraw(p_5A) + ggdraw(p_5B) + ggdraw(p_5C))

ggsave("fig/Fig_5BC.png", width=18, height=7, dpi=1200)
```


